\smalltitle{سوال 5}
\begin{enumerate}
    \item درست. از آنجا که ما فقط می‌توانیم منابعی را به پردازه اختصاص دهیم که فقط شماره‌ی آنها بیشتر از
    بقیه‌ی منابع است، نمی‌توان هیچ دوری را در این پروسه ایجاد کرد. پس در نتیجه این کار باعث
    ددلاک نمی‌شود. از طرفی دیگر
    \lr{starvation}
    داریم. فرض کنید که کلی پراسس داریم که می‌خواهند از منبع 2 استفاده کنند و یک پراسس داریم که می‌خواهد
    از منبع 1 و 2 استفاده بکند. در این صورت پراسس منبع 1 را می‌گیرد ولی سر منبع 2 می‌تواند تا ابد در حال
    صبر کردن باشد اگر بدون درنگ منبع 2 به بقیه‌ی پردازه‌ها اختصاص یابد.
    \item غلط. فرض کنید که پردازه‌ی 1 در حال پایپ کردن خروجی خود در پردازه‌ی 2 است. فرض کنید که هنوز
    خروجی برنامه‌ی 1، از بافر خود
    \lr{flush}
    نشده است. پس پردازه‌ی 2 در حال صبر کردن و بلوک شدن بر روی خروجی پردازه‌ی 1 است ولی هیچ ددلاکی وجود ندارد
    چرا که در آینده این خروجی به برنامه‌ی 2 می‌رسد.
    \item غلط. فرض کنید که دو پردازه‌ی 1 و 2 و دو لاک 1 و 2 و دو هسته‌ی 1 و 2 داریم.
    در پردازه‌ی 1 در ابتدا 1 و سپس 2 را لاک می‌کنیم.
    در پردازه‌ی 2 نیز در ابتدا 2 و سپس 1 را لاک می‌کنیم.
    فرض کنید که این دو پردازه همزمان در دو هسته‌ی مختلف اجرا می‌شوند و اولین دستور لاک هر کدام از این پردازه‌ها
    اجرا می‌شود. پس در دستور دوم ددلاک داریم. چرا که هیچ گاه این دو لاک آزاد نمی‌شوند.
    \item درست با فرض بی‌نهایت بودن فضای دیسک. ما عملا به کمک
    \lr{spooling}
    در حال از بین بردن
    \lr{mutual execution}
    هستیم. طبق مطالبی که من در منابع و
    \link{https://en.wikipedia.org/wiki/Spooling}{ویکیپدیا}
    خواندم، این سیستم امروزه برای پرینتر‌ها استفاده می‌شود. بدین صورت که صفحات و داکیومنت‌هایی که قرار است
    پرینتر پرینت بگیرید به صورت یک صف در دیسک سخت قرار می‌گیرند و یکی یکی پرینتر صفحات آن را پرینت می‌کند.
    هر جاب جدید به آخر صف اضافه می‌شود و پرینتر از اول صف می‌خواند. پس عملا با این کار ما امکان دسترسی دو
    برنامه به صورت همزمان به پرینتر را می‌گیریم چرا که صرفا این برنامه‌ها در
    نوشتن در دیسک رقابت می‌کنند.

    اما یک
    \lr{pitfall}
    ریز وجود دارد. فرض کنید پرینتری که داریم تنها زمانی می‌تواند پرینت کند که تمام دیتای آن اماده باشد
    و امکان
    \lr{stream}
    کردن وجود نداشته باشد. در این حالت فرض کنید که یک فایل بزرگتر از فضای
    \lr{spooling}
    را به
    \lr{job queue}
    می‌خواهیم اضافه کنیم. در این حالت دیسک پر می‌شود پس جاب دیگری نمی‌تواند اضافه شود و همچنین پرینتر
    نیز چیزی را پرینت نمی‌کند پس به ددلاک بر می‌خوریم! اما با فرض بی نهایت بودن فضای ذخیره سازی مشکلی
    پیش نمی‌آید.
    
    \link{https://www.geeksforgeeks.org/difference-between-deadlock-prevention-and-deadlock-avoidance/}{منبع 1}
    \link{https://www.uobabylon.edu.iq/eprints/publication\_3\_15609\_44.pdf}{منبع 2}
\end{enumerate}