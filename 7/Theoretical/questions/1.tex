\smalltitle{سوال 1}
\\\noindent
در این سوال فرض می‌کنیم که تابع
\lr{compare and swap}
مانند اسلاید‌ها به صورت زیر پیاده سازی شده است:
\codesample{codes/cas.c}
\begin{enumerate}
    \item خیر ددلاکی نداریم و همچنین در تابع دوم لاکی نیز وجود ندارد!
    دقت کنید که در صورتی که مقدار
    \codeword{var1}
    برابر 1 باشد، با اینکه هیچ
    \lr{swap}ای
    انجام نمی‌شود ولی از حلقه خارج می‌شویم چرا که مقدار قدیمی
    \codeword{var1}
    برابر 1 بود و در نتیجه شرط حلقه
    \codeword{false}
    می‌شود! برای درست کردن این مشکل کافی است که
    \codeword{!}
    قبل از تابع را برداریم.
    با فرض وجود
    \lr{not}،
    جواب جفت سوالات الف و ب خیر است چرا که همان طور که گفته شد اصلا لاکی وجود ندارد.
    لازم به ذکر است زمانی که
    \codeword{var1}
    برابر 0 است نیز، در دور بعدی حلقه از حلقه خارج می‌شویم و در آن گیر نمی‌کنیم.

    \noindent
    اما از طرفی دیگر در صورتی که آن
    \codeword{!}
    را برداریم، در صورتی که از زمانبند
    \lr{non-preemptive}
    استفاده می‌کنیم، مشکلی پیش نمی‌آید چرا که هر کدام از توابع برای خودشان لاک را می‌گیرند و نگه می‌دارند
    و کارشان را انجام می‌دهد و لاک را در نهایت آزاد می‌کنند.
    \item از طرفی دیگر در صورتی که
    \lr{preemptive scheduler}
    را استفاده کنیم ممکن است که به ددلاک بر بخوریم. بدین صورت که فرض کنید که تابع
    \codeword{function1}
    خط اولش اجرا می‌شود و
    \codeword{var1}
    برابر 1 می‌شود. از طرفی دیگر نیز فرض کنید که بلافاصه
    \lr{context switch}
    اتفاق می‌افتد و تابع دوم شروع به کار می‌کند. در این تابع
    \codeword{var2}
    را برابر 1 می‌کنیم و در لوپی قرار می‌گیریم که سعی می‌کند که زمانی که
    \codeword{var1}
    برابر 0 بود، آنرا برابر 1 کند و از تابع خارج شود.
    از طرفی دیگر تابع اول نیز اینقدر
    \codeword{var2}
    را برابر یک قرار می‌دهد تا زمانی که مقدار اولیه‌ی آن برابر 0 باشد. پس در اینجا ددلاک رخ می‌دهد.
    \item stuff
    \item به صورت کلی الگوریتم‌های
    \lr{non preemptive}
    این مشکل را حل می‌کنند. این الگوریتم‌ها صبر می‌کنند که تا کار یک
    \lr{job}
    به صورت کامل تمام شود و پس آن سراغ کار بعدی می‌روند. پس هر منبعی که هر پراسس لاک کرده بود
    حتما آنلاک می‌شود چرا که اصلا پراسس تمام می‌شود قبل از اینکه
    \lr{CPU}
    دست کسی دیگر قرار بگیرد.
\end{enumerate}



