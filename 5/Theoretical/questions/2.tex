\smalltitle{سوال 2}
\begin{enumerate}
    \item زمانی که
    \lr{quantum time}
    برابر بی‌نهایت باشد. در این حالت هیچ وقت برنامه‌های در حال اجرا
    \lr{preempt}
    نمی‌شوند. فرض کنید بیشترین زمانی که یک برنامه می‌تواند طول بکشد برابر 
    $a$
    باشد. حال اگر
    \lr{quantum time}
    را برابر
    $a$
    قرار دهیم، قبل از اینکه بتوانیم برنامه‌ای را از
    \lr{CPU}
    خارج کنیم، کار آنها تمام می‌شود و برنامه‌‌ها به ترتیب نیز اجرا می‌شود پس دو الگوریتم فرقی ندارند.
    \item
    \begin{enumerate}
        \item \lr{SP}: در جفت آنها تغییر می‌کند.
        \item \lr{PC}: در جفت آنها تغییر می‌کند.
        \item \lr{PCB}: فقط در تغییر پراسس عوض می‌شود. در تغییر ترد
        \link{https://en.wikipedia.org/wiki/Thread\_control\_block}{TCB}
        عوض می‌شود.
        \item جداول حافظه: از آنجا که ترد‌ها به مموری همدیگر دسترسی دارند پس در
        \lr{context switch}
        ترد به ترد یک پردازه عوض نمی‌شود.
    \end{enumerate}
    \item صف
    \lr{forground}
    را به صورت
    \lr{RR}
    پیاده‌سازی می‌کنم. چرا که این یک سرور است و احتمال خوبی وجود دارد که کار
    \lr{interactive}
    کمتری قرار است با آن انجام ‌شود. پس یک
    \lr{round robin}
    با یک
    \lr{quantom time}
    معقول می‌تواند گزینه خوبی باشد.
    \\
    از طرفی صف
    \lr{background}
    را به صورت
    \lr{preemptive priority scheduling}
    پیاده سازی می‌کنم. در این الگوریتم صرفا با توجه به اولویتی که کاربران به کار‌هاییشان می‌دهند،
    این صف را پیاده سازی می‌کنیم.
    اگر محاسبات کوتاهی داشته باشیم این روش به نظر من خوب جواب می‌دهد؛ ولی اگر اکثرا محاسبات زمان بر
    باشند، این کار می‌تواند باعث
    \lr{starvation}
    یا مثلا گذاشتن زمان زیادی بر روی یک کار طولانی و زمان نذاشتن بر روی یک کار کوتاه شود.
    برای حل این مشکل می‌توان از
    \lr{aging}
    استفاده کرد. یعنی مثلا بعد از اجرا شدن
    $t$
    واحد زمانی از یک پردازه، یکی از اولویت آن کم کنیم.
    \item با اینکه تردها سبک‌تر از پردازه‌ها هستند ولی در عین حال خیلی هم سبک نیستند. به عنوان مثال
    درست کردن و خراب کردن آنها در ابعاد زیاد می‌تواند بسیار زمان بر باشد. برای همین است که
    \lr{async programming}
    به وجود آمده است که ساخت و خراب کردن ترد‌ها زمان بر نیست.
    برای ساخت ترد‌ها سیستم‌‌عامل باید
    \lr{PCB}
    آنها را آپدیت بکند و یک
    \lr{TCB}
    جدید درست کند که این زمان بر است. همین موضوع برای پاک کردن ترد‌ها نیز پابرجا است.
    \\
    از طرفی دیگر، سیستم‌عامل باید حواسش به این ترد‌ها باشد و بین‌ آنها
    \lr{CPU}
    را تقسیم کند یا اگر کار
    \lr{IO}
    دارند تشخیص دهد که آیا کار فلان ترد تمام شده است یا خیر.
    \item فرض کنید که سیستم‌عامل ما سه اولویت
    \lr{job}
    قبول می‌کند:
    \lr{Low, Medium, High}.
    فرض کنید که ما در یک
    \lr{job}
    با اولویت کم قرار است که یک
    \lr{lock}
    را نگه داشته‌ایم. به عنوان مثال در حال پرینت کردن با پرینتر هستیم. حال، یک جاب با اولویت بالا می‌آید که
    آن هم می‌خواهد چیزی را پرینت کند یا به صورت کلی‌تر همان لاک را نگه دارد. پس پراسس با اولویت بالاتر به حالت
    \lr{waiting}
    می‌رود تا زمانی که لاک آزاد شود یا در مثال ما پرینت انجام گیرد.
    (به عبارت دیگر منتظر پراسس با اولویت پایین می‌ماند.)
    حال فرض کنید که یک جاب که هیچ کاری با لاک ما ندارد،
    (در این مثال فرض کنید که یک پراسس
    \lr{cpu intensive})
    با اولویت متوسط در سیستم می‌آید. با اضافه شدن این جاب در
    \lr{process queue}
    ما، از آنجا که اولویت آن متوسط است، باعث می‌شود که جاب که اولویت پایین داشت از
    \lr{CPU}
    خارج شود و
    \lr{CPU}
    شروع به انجام دادن کار با اولویت متوسط کند. این موضوع باعث می‌شود که
    \lr{job}ای
    که اولویت بالا داشت بیشتر منتظر آزاد شدن لاک بماند. (و بیشتر صبر بکند.)
    شاید بشود به نحوی گفت که اولویت جاب متوسط را زیاد کردیم!
    \\
    برای حل این مشکل، یکی از کار‌هایی که می‌توان انجام داد،
    \lr{priority inheritance}
    است. در این روش کاری که می‌کنیم این است که زمانی که یک برنامه با اولویت
    $a$
    منتظر یک
    \lr{lock}
    است که توسط یک برنامه‌ی دیگر با اولویت
    $b (a > b)$
    گرفته شد، اولویت برنامه‌ی اول را به صورت موقت تبدیل به
    $a$
    می‌کنیم که سریع‌تر کار آن تمام شود و لاک آزاد شود. به عنوان مثال در مثالی که درباره‌ی پرینتر زدم، 
    به صورت موقت اولویت تسکی که
    \lr{low}
    بود را
    \lr{high}
    می‌کنیم. با این کار دیگر پردازه با اولویت
    \lr{medium}
    نمی‌تواند جلوی اجرا شدن پردازه با اولویت
    \lr{low}
    را بگیرد و در نتیجه سریع‌تر لاک مورد نظر را آزاد می‌کند.
    زمانی که لاک آزاد شد، اولویت پردازه اول را از
    \lr{high}
    به همان
    \lr{low}
    اولیه بر می‌گردانیم.
\end{enumerate}



