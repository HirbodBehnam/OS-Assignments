\smalltitle{سوال 3}
\begin{enumerate}
    \item یعنی در این سیستم، اولین
    \lr{page table}
    به 1024
    \lr{page table}
    دیگر اشاره می‌کند. هر کدام از
    \lr{entry}های
    این
    \lr{page table}ها
    نیز به 1024
    \lr{page table}
    دیگر اشاره می‌کنند. در این مرحله،
    \lr{page table}ها
    به آدرس مموری واقعی سیستم اشاره می‌کنند.
    پس اگر خواسته‌ی سوال را درست فهمیده باشم، حداکثر
    $1024 \times 1024$
    و حداقل
    $1$
    \lr{page table}
    در سطح دوم داریم.
    \item \lr{Slab allocator}
    برای \lr{allocate} کردن مموری کرنل استفاده می‌شود.
    فرض کنید که در کرنل می‌دانیم که قرار است چه استراکچر‌هایی با چه سایز‌هایی
    \lr{allocate}
    شوند. فرض کنید که مثلا برای هر پراسس به 2 کلیوبایت فضا نیاز داریم و برای هر فایل باز نیز به 3 کلیوبایت
    فضا نیاز داریم. برای هر کدام از این استراکچر‌ها یک
    \lr{cache}
    تعریف می‌کنیم. هر خانه‌ی
    \lr{cache}
    به یک
    \lr{slab}
    اشاره می‌کند که می‌تواند یکی از حالات زیر باشد:
    \begin{itemize}
        \item \lr{Empty}
        \item \lr{Partial}
        \item \lr{Full}
    \end{itemize}
    هر
    \lr{slab}
    معمولا یک
    \lr{page}
    از مموری را درگیر می‌کند.

    خوبی‌های این نوع
    \lr{allocation}
    این است که از آنجا که ما سایز استراکچر‌ها را میدانیم دیگر
    \lr{fragmentation}ی
    رخ نمی‌دهد. همچنین
    \lr{allocate} و \lr{deallocate}
    کردن بسیار سریع اتفاق می‌افتد.
    \item \lr{Local allocation} بدین معنی است که
    تنها صفحات پردازنده‌ای که درخواست مموری می‌دهد
    \lr{swap out} و \lr{swap in}
    می‌شوند و کاری به بقیه‌ی پردازنده‌ها نداریم. این باعث می‌شود که زمان اجرایی هر برنامه قابل پیش بینی تر باشد.
    دلیل این موضوع این است که اگر از
    \lr{global allocator}
    استفاده می‌کردیم، ممکن بود که
    \lr{page}
    یک برنامه‌ی تصادفی را
    \lr{swap out}
    می‌کردیم و این طور ممکن بود که زمان اجرای یک برنامه‌ی رندوم را چند برابر کنیم!
    (چرا که آن برنامه ممکن است که به \lr{swap in} که زمان بر است نیاز داشته باشد.)
    پس برای اینکه پیش بینی‌های ما به هم نخورد، بهتر است که از
    \lr{local allocator}
    استفاده کنیم که تنها سرعت اجرای برنامه‌ی فعلی تحت تاثیر قرار بگیرد.
\end{enumerate}