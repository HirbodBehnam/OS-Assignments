\smalltitle{سوال 4}
\begin{enumerate}
    \item در ابتدا فرض کنید که دو ترد به خاطر
    \lr{race}،
    مقدار
    \lr{dig}هایشان
    برابر شد. زمانی که این دو ترد وارد حلقه‌ی
    \codeword{for}
    دوم می‌شوند (بالای
    \lr{critical section})
    تردی که
    $i$
    کمتری دارد لاک به آن می‌رسد. دلیل این موضوع این است که در خط
    $dig[i] == dig[j] ~ \&\& ~ i >= j$
    هر دوی آنها
    \lr{dig}
    برابری دارند ولی از شرط دوم، لاک به تردی می‌رسد که
    $i$
    کمتری دارد. در ادامه‌ی کد نیز زمانی که
    \lr{dig}
    ترد کمتر وقتی صفر شد، آن یکی ترد از
    \lr{busy waiting}
    در می‌آید و وارد
    \lr{critical section}
    می‌شود. پس در این حالت
    \lr{race}
    نداریم و مسئله‌ی
    \lr{mutual exclusion}
    حل می‌شود.
    \\
    حال از طرفی دیگر فرض کنید که تمامی مقدار
    \lr{dig}
    مختلف باشند. همچنین فرض کنید که دو ترد همزمان وارد
    \lr{critical section}
    شده باشند. (فرض خلف)
    این بدین معنا است که هر دو ترد باید زمانی به آخرین حلقه‌ی
    \codeword{for}
    رسیده باشند. این موضوع نشان می‌دهد که این دو ترد باید
    \lr{dig}
    همدیگر را چک می‌کردند. از آنجا که فرض کردیم که مقادیر
    \lr{dig}
    متفاوت هستند، قطعا یکی بزرگتر از دیگری است. حال اگر دقت کنید خطی در
    \codeword{while}
    درونی داشتیم که چک می‌کرد
    $dig [i] > dig [j]$
    و اگر این شرط و
    $dig [j] != 0$
    درست بودند، ترد در
    \lr{spin lock}
    می‌رود. طبق فرض‌های مسئله نیز باید این اتفاق می‌افتاد. چرا که حتما یک
    \lr{dig}
    از دیگری بزرگتر است. پس یکی از ترد‌ها در
    \lr{busy wait}
    می‌ماند و دیگری وارد
    \lr{critical section}
    می‌شود. زمانی هم که کار ترد داخل
    \lr{critical section}
    تمام می‌شود، از آنجا که
    $dig[i]$
    را صفر می‌کند، شرط اول حلقه‌ی
    \codeword{while}
    نقض می‌شود و آن یکی ترد نیز وارد
    \lr{critical section}
    می‌شود. جا دارد که اشاره کنم که شرط
    $pick [j] != 0$
    برای این است که مطمئن شویم که مقدار
    \lr{dig}
    برای ترد
    $j$ام
    معتبر است.
    \item فرض کنید که دو ترد در حال اجرا شدن هستند.
    فرض کنید که ترد‌ها تا خط
    $pick[i] = 0$
    به ترتیب می‌روند پس آرایه‌ی
    \lr{dig}
    را به صورت
    $\{1, 2\}$
    در می‌آورند. حال فرض کنید که
    \lr{CPU}
    فقط در دست ترد اول قرار می‌گیرد و تا
    \lr{critical section}
    می‌رود. در همین حال که این ترد در
    \lr{critical section}
    است،  ترد دوم کارش را ادامه می‌دهد و در
    \codeword{while}
    دوم گیر می‌کند.
    زمانی که کار ترد اول تمام می‌شود،
    $dig[1]$
    را برابر 0 می‌کند و به حلقه‌ی بالا بر می‌گردد.
    در همین حال ترد دوم وارد
    \lr{critical section}
    می‌شود. حال فرض کنید که در همین حین که  ترد دوم در
    \lr{critical section}
    است، ترد اول
    \lr{max}
    خودش را در می‌آورد و آنرا در
    \lr{dig}
    قرار می‌دهد. پس در حال حاضر آرایه برابر
    $\{3, 2\}$
    است. حال فرض کنید که همین چرخه تا بی‌نهایت ادامه پیدا کند. مشاهده می‌شود که اعداد آرایه
    بدون محدودیت زیاد می‌شوند.
    \item فرض کنید که در مثال قبلی بر 3 باقی‌مانده می‌گیریم.
    در مرحله‌ی آخر آرایه‌ی
    \lr{dig}
    به صورت
    $\{0, 2\}$
    در می‌آید. زمانی که این اتفاق می‌افتد و آرایه آپدیت می‌شود، فرض کنید که کار ترد دوم نیز تمام می‌شود و
    \lr{dig}
    خودش را آپدیت می‌کند. در نتیجه آرایه بعد از تغییر به صورت
    $\{0, 1\}$
    در می‌آید.
    حال مشکلی که در اینجا پیش می‌آید این است که ترد اول، برای ترد دوم در
    \codeword{while}
    دوم گیر نمی‌کند، چرا که
    \lr{dig[2]}
    برابر صفر نیست و
    $dig[1] \ge dig[2]$
    نیست.
    ($0 < 1$)
    پس ترد اول وارد
    \lr{critical section}
    می‌شود. حال برای ترد دوم اصلا شرط اول برقرار نیست. یعنی اینکه
    $dig[1] == 0$
    است پس اصلا در
    \lr{busy wait}
    نمی‌رویم و این ترد نیز وارد
    \lr{critical section}
    می‌شود.
\end{enumerate}




