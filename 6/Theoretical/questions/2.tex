\smalltitle{سوال 2}
\begin{enumerate}
    \item کد را به صورت زیر می‌زنیم:
    \codesample{code/2.c}
    در هر کدام از تراکنش‌ها یک متغیر فقط خوانده می‌شود و متغیر دیگر فقط نوشته می‌شود. از آنجا که حتی نوشتن
    خالی نیاز به
    \lr{exclusive lock}
    دارد، متغیر که نوشته می‌شود را
    \lr{XLock}
    می‌کنیم و آن یکی متغیر را
    \lr{SLock}.
    در نهایت نیز جفت لاک‌ها را آزاد می‌کنیم.
    \item مشکلی ندارد. با این نحوه‌ی لاک کردن عملا تراکنش‌ها را به صورت کلی ایزوله می‌کنیم. یعنی انگار که
    جفت آنها به صورت سری آماده‌اند. در قسمت بعد کمی بهتر این موضوع را توضیح داده‌ام.
    \item نه امکان ددلاک وجود ندارد.
    دلیل این موضوع این است که اگر در ابتدا تراکنش 1 شروع شود،
    $n$
    به صورت
    \lr{shared}
    لاک می‌شود. حال دقت کنید که با این لاک، تراکنش شماره دو دیگر نمی‌تواند تحت هیچ شرایطی دستور
    \codeword{XLock(n)}
    را اجرا کند. چرا که
    $n$
    به صورت
    \lr{shared}
    لاک شده است و ما می‌خواهیم که به صورت
    \lr{exclusive}
    لاک را انجام دهیم. پس باید منتظر بمانیم که آن لاک
    \lr{shared}
    نیز
    \lr{unlock}
    شود.
    دقیقا با همین منطق فرض کنید که تراکنش دو اول اجرا شود. حال بر روی
    $n$
    یک لاک
    \lr{exclusive}
    داریم. پس دیگر هیچ کس نمی‌تواند آنرا لاک کند و ددلاک رخ نمی‌دهد. یعنی نه تراکنش شماره 1 می‌تواند از خط
    اول خود جلوتر برود و نه تراکنش شماره دو.
    برای آخرین حال نیز فرض کنید که دو تراکنش شماره 1 همزمان آمده‌اند. جفت این تراکنش‌ها از خط
    \codeword{SLock(n)}
    عبور می‌کنند ولی فقط یک تراکنش می‌تواند وارد
    \codeword{XLock(m)}
    شود و در نتیجه بازم مشکلی به وجود نمی‌آید.

    از طرفی دیگر یک کدی در زیر آمده است که باعث می‌شود ددلاک در آن رخ دهد.
    \codesample{code/2-wrong.c}
    \noindent
    در این کد فرض کنید که تراکنش اول خط
    \codeword{XLock(m)}
    را اجرا می‌کند و تراکنش دوم خط
    \codeword{XLock(n)}
    را. در این صورت جفت تراکنش‌ها در گرفتن لاک اشتراکی
    $n$ و $m$
    گیر می‌کنند و ددلاک به وجود می‌آید.
\end{enumerate}



