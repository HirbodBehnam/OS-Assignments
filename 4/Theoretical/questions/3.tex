\smalltitle{سوال 3}
\begin{enumerate}
    \item غلط. \lr{user thread}ها نیازی اصلا به \lr{syscall} ندارند چرا که اصلا سیستم‌عامل از وجود آنها خبر ندارد.
    خود برنامه‌ای که این
    \lr{user thread}ها
    را ساخته‌است باید مکانیزمی داشته باشد که بتواند دیتا بین
    \lr{user thread}ها جا به جا بکند.
    معمولا این کار از طریق چنل صورت می‌گیرد.
    به عنوان مثال می‌توانید چنل‌ها را در زبان
    \link{https://go.dev/tour/concurrency/2}{Go}
    و
    \link{https://tokio.rs/tokio/tutorial/channels}{Rust}
    مشاهده کنید.
    \item درست است.
    \item غلط. از انجا که همه چی بالاخره بر روی ترد‌های یک پردازه اجرا می‌شود تمام
    \lr{user thread}ها
    به تمام مموری برنامه دسترسی دارند که این عبارت است از تمامی فضای آدرس ترد‌های یوزر و کرنل.
    \item غلط است. همان طور که در سوال قبل نیز توضیح دادم معمولا زمان بندی
    \lr{kernel thread}ها
    به کمک دستور العمل‌های
    \lr{CPU}
    یا زبان‌های سطح پایین مثل
    \lr{assembly}
    نوشته شده‌‌اند که خیلی سریع است. از طرفی دیگر معمولا
    \lr{scheduler}های
    در سطح برنامه کاربر در همان زبان نوشته شده است. یعنی مثلا زمان بند پایتون ممکن است که قسمتی از آن در پایتون
    نوشته باشد که باعث می‌شود خیلی کند شود.
\end{enumerate}






