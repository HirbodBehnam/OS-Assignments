\smalltitle{سوال 6}\\
\noindent
% https://stackoverflow.com/a/26355613/4213397
\begin{itemize}
    \item در حالت کمترین تمام زمان می‌تواند یک پراسس در حال اجرا باشد که هیچ
    \lr{fork}ی
    انجام نگیرد.
    \item همان طور که گفته شد کمینه برابر 1 است زمانی که هیچ \lr{fork} صورت نگیرد.
    حال، حالت بیشینه را تحلیل می‌کنیم. در ابتدا در تابع
    \lr{main}
    تابع
    \lr{randomFork}
    فراخوانی شده است. ما فعلا مسئله را بدون توجه به این تابع حل می‌کنیم و در نهایت جواب نهایی را ضرب در
    دو می‌کنیم.
    حال به بررسی تابعی که ترد جدید دارد اجرا می‌کند می‌پردازیم. اول از همه دقت کنید که زمانی که
    \lr{fork}
    می‌کنیم تمامی ترد‌ها غیر از آن تردی که
    \lr{fork}
    را صدا زده می‌میرند و آن ترد، ترد اصلی می‌شود. این ترد، 3 پردازه‌ی دیگر را می‌سازد. دقت کنید که همان
    طور که گفتم این سه پردازه هیچ تردی دیگری ندارند و دیگر
    \lr{fork}های
    بیرون ترد کاری نمی‌کند. (چرا که این تنها ترد برنامه می‌شود)
    در بیرون ترد نیز دو بار
    \lr{randomMess}
    صدا شده است که برابر است با چهار بار صدا کردن
    \lr{fork}
    (حداکثر).
    این موضوع نشان می‌دهد که
    $2^4$
    پراسس جدید ساخته می‌شود. پس در نهایت
    $16+3=19$
    پراسس ممکن است که ساخته شود. در انتها همان طور که در اول این قسمت گفته شد، جواب نهایی برابر
    $19 \times 2 = 38$
    است.
    \item زمانی که ما تابع
    \lr{randomFork}
    اول را اجرا می‌کنیم بی برو برگرد مقدار
    \codeword{cnt}
    یکی زیاد می‌شود. سپس وقتی که ترد جدید را می‌سازیم چندین اتفاق می‌تواند بیفتد.
    یکی از این اتفاق‌ها این است که ترد جدید زودتر از ترد اصلی کارش تمام شود. اگر این اتفاق بیفتد، دو
    \lr{randomFork}
    که در تابع
    \lr{randomMess}
    هستند باعث می‌شوند که
    \codeword{cnt}
    برابر 3 شود و 3 چاپ شود.
    از طرفی دیگر ممکن است که کد اول به
    \lr{join}
    برسد و سپس ترد شروع به اجرا شدن بکند. اگر این اتفاق بیفتد، تابع
    \lr{randomMess}
    در ترد اصلی زودتر اجرا می‌شود و
    \codeword{cnt}
    در ابتدایی که ترد دوم شروع به کار می‌خواهد بکند برابر 3 است. پس جواب نهایی 5 می‌شود.
    از طرفی دیگر به خاطر
    \lr{race}
    ممکن است که 4 را نیز ببینیم. وقتی که در
    \lr{main thread}
    فقط یک بار
    \codeword{cnt++}
    اجرا شده باشد.
    \\
    برای پرینت دوم در صورتی که هیچ
    \lr{data race}ی
    رخ ندهد، 7 چاپ می‌شود.
    در صورتی که
    \lr{race}
    داشته باشم، 5 و 6 نیز می‌تواند چاپ شود. به عنوان مثال فرض کنید که ترد جدید می‌خواهد که در دومین
    \codeword{cnt++}
    مقدار 3 را در
    \codeword{cnt}
    بنویسید. اما زمانی که می‌خواهد بنویسید به دلیلی ترد از
    \lr{cpu}
    خارج می‌شود و تا زمانی که قرار است
    \lr{join}
    صورت بگیرد در
    \lr{cpu}
    بر نمی‌گردد. در این صورت مقدار
    \codeword{cnt}
    برابر 3 می‌شود بعد از تمام شدن
    \lr{join}.
    پس در ادامه‌ی کد صرفا دو بار
    \codeword{cnt++}
    می‌شود و مقدار نهایی برابر 5 می‌شود. به طرز مشابه می‌توان حالاتی را مثال زد که
    \codeword{cnt}
    برابر 6 باشد.
\end{itemize}