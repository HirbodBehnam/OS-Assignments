\smalltitle{سوال 2}
\begin{enumerate}
    \item ما در هر برنامه چندین
    \lr{user thread}
    داریم که در اکثر زبان‌ها
    \lr{task}
    نامیده می‌شوند. هر برنامه ممکن است که یک یا چند
    \lr{kernel thread}
    داشته باشد. برنامه‌ی در حال اجرا این
    \lr{task}ها
    را بدون داخالت کرنل سیستم‌عامل در
    \lr{kernel thread}ها
    \lr{context switch}
    می‌کند. به عبارتی دیگر
    \lr{async programming}
    به ما کمک می‌کند که بر روی یک
    \lr{kernel thread}
    چندین تسک با
    \lr{scheduling}
    داخل خود برنامه‌ای اجرا کنیم.
    \item در مولتی تردینگ ما از ترد‌های سیستم‌عامل استفاده می‌کنیم تا کد برنامه‌ را به صورت موازی
    اجرا کنیم. در عوض ما در
    \lr{async programming}
    بر روی یک ترد کرنل چندین
    \lr{task}
    یا به عبارت دقیق‌تر
    \lr{CPU state}
    داریم. یکی از تفاوت‌های بزرگ این است که تمام کار‌های ترد‌ها مثل
    \lr{context switching}
    را سیستم‌عامل بر عهده دارد ولی برنامه این وظیفه را در
    \lr{async programming}
    بر عهده دارد.
    یکی از تفاوت‌های دیگر این است که
    \lr{kernel thread}ها
    از نوع
    \linebreak
    \link{https://en.wikipedia.org/wiki/Preemption\_(computing)}{\lr{Preemptive Scheduling}}
    است ولی معمولا تسک‌ها در
    \lr{async programs}
    به صورت
    \link{https://en.wikipedia.org/wiki/Cooperative_multitasking}{\lr{Cooperative Scheduling}}
    است.
    \\
    یکی از جا‌هایی که
    \lr{async programming}
    قدرت خودش را نشان می‌دهد زمانی است که ما نیاز به
    \lr{IO}
    داریم مخصوصا
    \lr{socket programming}.
    امروزه تقریبا تمامی وب سرور‌ها از
    \lr{asynchronous programming}
    استفاده می‌کنند. به این صورت که فرض کنید یک
    \lr{task}
    داریم که قرار است که 100 بایت را در یک سوکت بنویسد.
    اتفاقی که می‌افتد این است درخواست نوشتن این دیتا در سوکت داده می‌شود و همزمان با آن این
    \lr{task}
    از ترد خارج می‌شود و تسک دیگری جایگزین آن می‌شود. هر چند وقت یک بار می‌توان به این تسک سر سز که آیا
    کار نوشتن در سوکت آن تمام شده است یا خیر. البته دقت کنید که سیستم‌عامل نیز باید از
    \lr{API}های
    \lr{asynchronous IO}
    مثل
    \link{https://en.wikipedia.org/wiki/Io\_uring}{io\_uring}
    یا
    \link{https://en.wikipedia.org/wiki/Epoll}{epoll}
    پشتیبانی بکند.
    \\
    از طرفی دیگر در صورتی که بخواهیم که برنامه‌ای بنویسیم که بخواهیم چند ترد اجرا کند و ترد‌ها اصلا کاری به
    \lr{syscall}های
    \lr{IO}
    نداشته باشند
    (مثلا برنامه‌های ریاضی محور که یک جوابی را محاسبه می‌کنند)،
    \lr{multithreading}
    خیلی بهتر است. دلیل این موضوع این است که
    \lr{context switch}
    کردن بین
    \lr{task}‌ها
    به شدت کند‌تر از
    \lr{context switch}
    بین ترد‌ها است.
    \\
    اگر بخواهم دقیق‌تر توضیح دهم، زمانی
    \lr{multithreading}
    بهتر است که
    \lr{task}هایی
    که قرار است اجرا کنیم، خیلی کم در حالت
    \lr{sleeping} یا \lr{waiting}
    قرار گیرند و اکثر وقت در
    \lr{ready} یا \lr{running}
    باشند. چرا که اگر هر کدام از این
    \lr{task}ها
    به یک ترد کرنل مپ شوند، ترد‌ها سربار زیادی بر روی سیستم‌عامل قرار می‌دهند. همچنین دقت کنید که ساخت و پاکسازی
    ترد زمان زیادی میبرد. پس اگر قرار است
    \lr{task}های زیادی
    در زمان کوتاه درست شوند که سریع هم میمیرند، بهتر است که از
    \lr{asynchronous programming}
    استفاده کنیم. یک وب‌سرور دقیقا جفت این ویژگی‌ها را دارد. یکی اینکه معمولا ریکوست‌های زیادی را در
    بازه‌ی کوتاهی دریافت می‌کند که طول عمر آنها کم است
    (مثلا در 10 میلیثانیه جواب داده می‌شوند)
    و اکثر وقت آنها در
    \lr{waiting}
    است که دیتا یا از سوکت خوانده شود و یا در آن نوشته شود.
    \item به جواب قسمت قبل مراجعه شود! از هر طرف یک مثال آورده‌ام.
    \item \lr{C\#}, \lr{Python}, \lr{Rust}, \lr{Golang}
\end{enumerate}



